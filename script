import os
import glob
import csv
import statistics
import re
import logging
from collections import defaultdict
from datetime import datetime
from xml.etree import ElementTree as ET
from zipfile import ZipFile, ZIP_DEFLATED

from dotenv import load_dotenv
import xlsxwriter


# =====================================================
# LOGGING
# =====================================================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
)

# ordre des APIs pour les onglets Data*
LABEL_ORDER = [
    "Genera Token",
    "Purchase",
    "Policy",
    "Generate PDF",
    "Cancel",
]

# namespace WordprocessingML
W_NS = "http://schemas.openxmlformats.org/wordprocessingml/2006/main"


def w(tag: str) -> str:
    """Helper namespac√© pour Word (<w:...>)."""
    return f"{{{W_NS}}}{tag}"


# =====================================================
# ENV
# =====================================================
def load_env():
    load_dotenv()

    results_folder = os.getenv("RESULTS_FOLDER")
    output_file = os.getenv("OUTPUT_FILE", "recap_scenarios.xlsx")
    doc_template = os.getenv("DOC_TEMPLATE")
    doc_output = os.getenv("DOC_OUTPUT")

    logging.info("RESULTS_FOLDER = %s", results_folder)
    logging.info("OUTPUT_FILE   = %s", output_file)
    logging.info("DOC_TEMPLATE  = %s", doc_template)
    logging.info("DOC_OUTPUT    = %s", doc_output)

    if not results_folder:
        raise ValueError("La variable RESULTS_FOLDER n'est pas d√©finie dans le fichier .env")
    if not os.path.isdir(results_folder):
        raise ValueError(f"Le dossier RESULTS_FOLDER n'existe pas : {results_folder}")

    # normalise OUTPUT_FILE si besoin
    if os.path.isdir(output_file) or not os.path.splitext(output_file)[1]:
        output_file = os.path.join(output_file, "recap_scenarios.xlsx")

    return results_folder, output_file, doc_template, doc_output


# =====================================================
# FICHIERS SC√âNARIOS
# =====================================================
def extract_users_from_filename(path: str) -> int:
    name = os.path.basename(path)
    m = re.search(r"results-(\d+)-user", name)
    if m:
        return int(m.group(1))
    return 999999


def find_scenario_files(results_folder: str):
    pattern = os.path.join(results_folder, "IDP API-results-*user*.csv")
    logging.info("Recherche des fichiers avec le pattern : %s", pattern)
    files = glob.glob(pattern)
    if not files:
        raise FileNotFoundError(f"Aucun fichier trouv√© avec le pattern : {pattern}")
    files = sorted(files, key=extract_users_from_filename)
    logging.info("Nombre de fichiers trouv√©s : %d", len(files))
    for f in files:
        logging.info(" - %s", f)
    return files


# =====================================================
# LECTURE CSV JMETER
# =====================================================
def read_jmeter_csv(path: str):
    logging.info("Lecture du fichier CSV : %s", path)
    rows = []
    with open(path, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for r in reader:
            rows.append(r)
    logging.info("  -> %d lignes lues (hors en-t√™te)", len(rows))
    return rows


def to_float(value, default=None):
    try:
        return float(value)
    except Exception:
        return default


def to_bool_success(value):
    if value is None:
        return False
    v = str(value).strip().lower()
    return v in ("true", "1", "yes", "y")


def percentile(values, p):
    if not values:
        return None
    values = sorted(values)
    k = (len(values) - 1) * (p / 100.0)
    f = int(k)
    c = min(f + 1, len(values) - 1)
    if f == c:
        return values[int(k)]
    d0 = values[f] * (c - k)
    d1 = values[c] * (k - f)
    return d0 + d1


def compute_execution_range_string(rows):
    timestamps = []
    for r in rows:
        ts = r.get("timeStamp")
        if ts is None:
            continue
        try:
            timestamps.append(int(ts))
        except ValueError:
            continue

    if not timestamps:
        return ""

    start_ts = min(timestamps) / 1000.0
    end_ts = max(timestamps) / 1000.0

    start_dt = datetime.fromtimestamp(start_ts)
    end_dt = datetime.fromtimestamp(end_ts)

    fmt = "%d/%m/%y %I:%M %p"
    return f"{start_dt.strftime(fmt)} - {end_dt.strftime(fmt)}"


# =====================================================
# CALCUL R√âCAP SC√âNARIO
# =====================================================
def compute_recap(rows):
    logging.info("Calcul du tableau r√©capitulatif pour le sc√©nario...")
    labels = {}

    for r in rows:
        label = r.get("label")
        elapsed_raw = r.get("elapsed")
        success_raw = r.get("success")

        if label is None or elapsed_raw is None:
            continue

        elapsed = to_float(elapsed_raw)
        if elapsed is None:
            continue

        success = to_bool_success(success_raw)

        if label not in labels:
            labels[label] = {"times": [], "errors": 0}

        labels[label]["times"].append(elapsed)
        if not success:
            labels[label]["errors"] += 1

    recap = []
    total_samples_all = 0
    all_times = []
    total_errors_all = 0

    for label, data in sorted(labels.items(), key=lambda x: x[0]):
        times = data["times"]
        errors = data["errors"]
        samples = len(times)
        if samples == 0:
            continue

        avg = statistics.mean(times)
        mn = min(times)
        mx = max(times)
        std_dev = statistics.pstdev(times) if samples > 1 else 0.0
        p90 = percentile(times, 90)
        p95 = percentile(times, 95)
        p99 = percentile(times, 99)
        err_pct = (errors / samples * 100.0) if samples else 0.0

        recap.append({
            "Label": label,
            "Samples": samples,
            "Average (ms)": round(avg, 2),
            "Min (ms)": mn,
            "Max (ms)": mx,
            "Std Dev (ms)": round(std_dev, 2),
            "90% Line (ms)": round(p90, 2) if p90 is not None else "",
            "95% Line (ms)": round(p95, 2) if p95 is not None else "",
            "99% Line (ms)": round(p99, 2) if p99 is not None else "",
            "Error %": round(err_pct, 2),
        })

        total_samples_all += samples
        total_errors_all += errors
        all_times.extend(times)

    # ligne TOTAL
    if all_times:
        total_avg = statistics.mean(all_times)
        total_min = min(all_times)
        total_max = max(all_times)
        total_std = statistics.pstdev(all_times) if len(all_times) > 1 else 0.0
        total_err_pct = (total_errors_all / total_samples_all * 100.0) if total_samples_all else 0.0
        p90 = percentile(all_times, 90)
        p95 = percentile(all_times, 95)
        p99 = percentile(all_times, 99)

        recap.append({
            "Label": "TOTAL",
            "Samples": total_samples_all,
            "Average (ms)": round(total_avg, 2),
            "Min (ms)": total_min,
            "Max (ms)": total_max,
            "Std Dev (ms)": round(total_std, 2),
            "90% Line (ms)": round(p90, 2) if p90 is not None else "",
            "95% Line (ms)": round(p95, 2) if p95 is not None else "",
            "99% Line (ms)": round(p99, 2) if p99 is not None else "",
            "Error %": round(total_err_pct, 2),
        })

    logging.info("  -> %d lignes dans le tableau r√©cap (y compris TOTAL)", len(recap))
    return recap


# =====================================================
# EXCEL
# =====================================================
def sanitize_sheet_name(name: str) -> str:
    name = re.sub(r'[:\\/?*\[\]]', "_", name)
    if len(name) > 31:
        name = name[:31]
    if not name:
        name = "Sheet"
    return name


def write_excel(output_file: str,
                scenarios_data: dict,
                scenarios_users: list,
                rt_matrix: dict,
                err_matrix: dict):
    logging.info("Cr√©ation du fichier Excel : %s", output_file)
    workbook = xlsxwriter.Workbook(output_file)

    header_fmt = workbook.add_format({
        "bold": True,
        "bg_color": "#D9D9D9",
        "border": 1
    })
    cell_fmt = workbook.add_format({"border": 1})
    num_fmt = workbook.add_format({"border": 1, "num_format": "0.00"})
    int_fmt = workbook.add_format({"border": 1, "num_format": "0"})

    # feuilles par sc√©nario (d√©tail)
    for sheet_name_raw, rows in scenarios_data.items():
        sheet_name = sanitize_sheet_name(sheet_name_raw)
        logging.info("  -> Cr√©ation de la feuille : %s", sheet_name)

        ws = workbook.add_worksheet(sheet_name)

        if not rows:
            continue

        headers = [
            "Label",
            "Samples",
            "Average (ms)",
            "Min (ms)",
            "Max (ms)",
            "Std Dev (ms)",
            "90% Line (ms)",
            "95% Line (ms)",
            "99% Line (ms)",
            "Error %",
        ]

        for col, h in enumerate(headers):
            ws.write(0, col, h, header_fmt)

        for row_idx, row in enumerate(rows, start=1):
            for col_idx, h in enumerate(headers):
                val = row.get(h, "")
                if isinstance(val, (int, float)):
                    ws.write(row_idx, col_idx, val, num_fmt)
                else:
                    ws.write(row_idx, col_idx, str(val), cell_fmt)

        ws.set_column(0, 0, 40)
        ws.set_column(1, len(headers) - 1, 16)

    # Data Time Response Time
    ws_rt = workbook.add_worksheet("Data Time Response Time")
    ws_rt.write(0, 0, "Scenario", header_fmt)
    ws_rt.write(0, 1, "API", header_fmt)
    ws_rt.write(0, 2, "Response Time (ms)", header_fmt)

    row_idx = 1
    for users in sorted(scenarios_users):
        start_row = row_idx
        for label in LABEL_ORDER:
            val = rt_matrix.get(label, {}).get(users)
            if val is None:
                continue
            ws_rt.write(row_idx, 1, label, cell_fmt)
            ws_rt.write(row_idx, 2, int(round(val)), int_fmt)
            row_idx += 1
        end_row = row_idx - 1
        if end_row >= start_row:
            ws_rt.merge_range(start_row, 0, end_row, 0, users, int_fmt)

    ws_rt.set_column(0, 0, 12)
    ws_rt.set_column(1, 1, 20)
    ws_rt.set_column(2, 2, 20)

    # Data Error Rate
    ws_err = workbook.add_worksheet("Data Error Rate")
    ws_err.write(0, 0, "Scenario", header_fmt)
    ws_err.write(0, 1, "API", header_fmt)
    ws_err.write(0, 2, "Error Rate (%)", header_fmt)

    row_idx = 1
    for users in sorted(scenarios_users):
        start_row = row_idx
        for label in LABEL_ORDER:
            val = err_matrix.get(label, {}).get(users)
            if val is None:
                continue
            ws_err.write(row_idx, 1, label, cell_fmt)
            if abs(val - round(val)) < 1e-9:
                s = str(int(round(val)))
            else:
                s = f"{val:.2f}"
            ws_err.write(row_idx, 2, s, cell_fmt)
            row_idx += 1
        end_row = row_idx - 1
        if end_row >= start_row:
            ws_err.merge_range(start_row, 0, end_row, 0, users, int_fmt)

    ws_err.set_column(0, 0, 12)
    ws_err.set_column(1, 1, 20)
    ws_err.set_column(2, 2, 20)

    workbook.close()
    logging.info("Fichier Excel finalis√©.")


# =====================================================
# WORD - MODIF DIRECTE DU DOCX (ZIP + XML)
# =====================================================
def build_parent_map(root):
    """map enfant -> parent pour faciliter les insertions."""
    return {child: parent for parent in root.iter() for child in parent}


def build_word_table(recap_rows):
    """Construit un <w:tbl> simple √† partir du recap."""
    tbl = ET.Element(w("tbl"))

    # un petit style de table minimaliste (Word ajustera)
    tbl_pr = ET.SubElement(tbl, w("tblPr"))
    ET.SubElement(tbl_pr, w("tblBorders"))
    # pas de bordures d√©taill√©es pour garder simple

    headers = [
        "Label",
        "Samples",
        "Average (ms)",
        "Min (ms)",
        "Max (ms)",
        "Std Dev (ms)",
        "90% Line (ms)",
        "95% Line (ms)",
        "99% Line (ms)",
        "Error %",
    ]

    def add_row(values, bold=False):
        tr = ET.SubElement(tbl, w("tr"))
        for val in values:
            tc = ET.SubElement(tr, w("tc"))
            p = ET.SubElement(tc, w("p"))
            r = ET.SubElement(p, w("r"))
            if bold:
                rpr = ET.SubElement(r, w("rPr"))
                b = ET.SubElement(rpr, w("b"))
                b.set(w("val"), "1")
            t = ET.SubElement(r, w("t"))
            t.text = "" if val is None else str(val)

    # header
    add_row(headers, bold=True)

    # data rows
    for row in recap_rows:
        values = [
            row.get("Label", ""),
            row.get("Samples", ""),
            row.get("Average (ms)", ""),
            row.get("Min (ms)", ""),
            row.get("Max (ms)", ""),
            row.get("Std Dev (ms)", ""),
            row.get("90% Line (ms)", ""),
            row.get("95% Line (ms)", ""),
            row.get("99% Line (ms)", ""),
            row.get("Error %", ""),
        ]
        add_row(values, bold=(row.get("Label") == "TOTAL"))

    return tbl


def generate_word_report(template_path: str,
                         output_path: str,
                         scenario_keys: list,
                         scenarios_data: dict,
                         execution_ranges: dict):
    if not template_path or not output_path:
        logging.info("DOC_TEMPLATE ou DOC_OUTPUT non d√©fini, on saute la g√©n√©ration Word.")
        return

    if not os.path.isfile(template_path):
        logging.error("Le template Word n'existe pas : %s", template_path)
        return

    logging.info("G√©n√©ration du rapport Word √† partir de : %s", template_path)

    # on lit le document.xml du template
    with ZipFile(template_path, "r") as zin:
        xml_bytes = zin.read("word/document.xml")

    ET.register_namespace("w", W_NS)
    root = ET.fromstring(xml_bytes)
    parent_map = build_parent_map(root)

    # 1) Mise √† jour des dates d'ex√©cution
    #    -> on cherche chaque "Execution date" dans l'ordre,
    #       et on remplit la cellule correspondante
    exec_index = 0
    exec_dates = [execution_ranges.get(i + 1, "") for i in range(len(scenario_keys))]

    for t in root.iter(w("t")):
        if t.text and t.text.strip() == "Execution date":
            if exec_index >= len(exec_dates):
                break
            date_str = exec_dates[exec_index]
            exec_index += 1

            # remonter au <w:tr> (ligne du tableau)
            tr = t
            while tr is not None and tr.tag != w("tr"):
                tr = parent_map.get(tr)
            if tr is None:
                continue

            tcs = tr.findall(w("tc"))
            if len(tcs) < 2:
                continue
            date_tc = tcs[1]

            # on remplace le contenu texte du 2√®me <tc>
            found_t = date_tc.find(".//" + w("t"))
            if found_t is not None:
                found_t.text = date_str
            else:
                p = ET.SubElement(date_tc, w("p"))
                r = ET.SubElement(p, w("r"))
                new_t = ET.SubElement(r, w("t"))
                new_t.text = date_str

    # 2) Insertion des tableaux sous chaque "Response time"
    para_index = 0
    for p in root.iter(w("p")):
        # texte complet du paragraphe
        full_text = "".join(t.text or "" for t in p.iter(w("t"))).strip()
        if full_text == "Response time":
            if para_index >= len(scenario_keys):
                break
            scen_key = scenario_keys[para_index]
            para_index += 1

            recap_rows = scenarios_data.get(scen_key, [])
            if not recap_rows:
                continue

            tbl = build_word_table(recap_rows)

            parent = parent_map.get(p)
            if parent is None:
                continue
            # on ins√®re le tableau juste apr√®s le paragraphe
            children = list(parent)
            try:
                idx = children.index(p)
            except ValueError:
                continue
            parent.insert(idx + 1, tbl)

    # 3) on r√©-√©crit le document.xml modifi√© dans un nouveau docx
    new_xml = ET.tostring(root, encoding="utf-8", xml_declaration=True)

    with ZipFile(template_path, "r") as zin, ZipFile(output_path, "w", ZIP_DEFLATED) as zout:
        for item in zin.infolist():
            if item.filename == "word/document.xml":
                zout.writestr(item, new_xml)
            else:
                zout.writestr(item, zin.read(item.filename))

    logging.info("Rapport Word g√©n√©r√© : %s", output_path)


# =====================================================
# MAIN
# =====================================================
def main():
    try:
        results_folder, output_file, doc_template, doc_output = load_env()
        files = find_scenario_files(results_folder)

        scenarios_data = {}
        scenarios_users = []
        rt_matrix = defaultdict(dict)
        err_matrix = defaultdict(dict)
        execution_ranges = {}
        scenario_keys_in_order = []

        scenario_index = 0

        for f in files:
            logging.info("--------------------------------------------------")
            logging.info("Traitement du fichier sc√©nario : %s", f)

            users = extract_users_from_filename(f)
            if users not in scenarios_users:
                scenarios_users.append(users)

            rows = read_jmeter_csv(f)
            recap = compute_recap(rows)
            exec_range_str = compute_execution_range_string(rows)

            base_name = os.path.splitext(os.path.basename(f))[0]
            scenarios_data[base_name] = recap
            scenario_keys_in_order.append(base_name)

            scenario_index += 1
            execution_ranges[scenario_index] = exec_range_str

            for r in recap:
                if r["Label"] == "TOTAL":
                    continue
                label = r["Label"]
                rt_matrix[label][users] = r["Average (ms)"]
                err_matrix[label][users] = r["Error %"]

        write_excel(output_file, scenarios_data, scenarios_users, rt_matrix, err_matrix)
        logging.info("Excel OK ‚úÖ")

        generate_word_report(
            doc_template,
            doc_output,
            scenario_keys_in_order,
            scenarios_data,
            execution_ranges,
        )
        logging.info("Word OK ‚úÖ")
        logging.info("Termin√© üéâ")

    except Exception as e:
        logging.exception("‚ùå Erreur lors de l'ex√©cution du script : %s", e)


if __name__ == "__main__":
    main()
