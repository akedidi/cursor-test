import os
import glob
import csv
import statistics
import re
import logging
from collections import defaultdict
from datetime import datetime
from zipfile import ZipFile

from dotenv import load_dotenv
import xlsxwriter


# --------------------------------------------------------
# Logging
# --------------------------------------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
)

# Ordre des labels qu'on veut dans les synthèses
LABEL_ORDER = [
    "Genera Token",   # Token
    "Purchase",
    "Policy",
    "Generate PDF",
    "Cancel",
]


# --------------------------------------------------------
# .env
# --------------------------------------------------------
def load_env():
    load_dotenv()

    results_folder = os.getenv("RESULTS_FOLDER")
    output_file = os.getenv("OUTPUT_FILE", "recap_scenarios.xlsx")
    doc_template = os.getenv("DOC_TEMPLATE")
    doc_output = os.getenv("DOC_OUTPUT")

    logging.info("RESULTS_FOLDER = %s", results_folder)
    logging.info("OUTPUT_FILE   = %s", output_file)
    logging.info("DOC_TEMPLATE  = %s", doc_template)
    logging.info("DOC_OUTPUT    = %s", doc_output)

    if not results_folder:
        raise ValueError("La variable RESULTS_FOLDER n'est pas définie dans le fichier .env")
    if not os.path.isdir(results_folder):
        raise ValueError(f"Le dossier RESULTS_FOLDER n'existe pas : {results_folder}")

    # si OUTPUT_FILE est un dossier ou sans extension -> on ajoute un nom
    if os.path.isdir(output_file) or not os.path.splitext(output_file)[1]:
        output_file = os.path.join(output_file, "recap_scenarios.xlsx")
        logging.info("OUTPUT_FILE normalisé en : %s", output_file)

    return results_folder, output_file, doc_template, doc_output


# --------------------------------------------------------
# Recherche des fichiers
# --------------------------------------------------------
def extract_users_from_filename(path: str) -> int:
    """
    Extrait le nombre d'utilisateurs à partir du nom de fichier.
    Ex : ...results-1-users.csv -> 1
         ...results-12-user.csv -> 12
    """
    name = os.path.basename(path)
    m = re.search(r"results-(\d+)-user", name)
    if m:
        return int(m.group(1))
    return 999999  # au cas où


def find_scenario_files(results_folder: str):
    """
    On accepte :
      IDP API-results-1-user.csv
      IDP API-results-1-users.csv
    """
    pattern = os.path.join(results_folder, "IDP API-results-*user*.csv")
    logging.info("Recherche des fichiers avec le pattern : %s", pattern)
    files = glob.glob(pattern)

    if not files:
        raise FileNotFoundError(f"Aucun fichier trouvé avec le pattern : {pattern}")

    # Tri par nombre d'utilisateurs : 1,2,4,8,12...
    files = sorted(files, key=extract_users_from_filename)

    logging.info("Nombre de fichiers trouvés : %d", len(files))
    for f in files:
        logging.info(" - %s", f)

    return files


# --------------------------------------------------------
# Lecture CSV
# --------------------------------------------------------
def read_jmeter_csv(path: str):
    logging.info("Lecture du fichier CSV : %s", path)
    rows = []
    with open(path, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for r in reader:
            rows.append(r)
    logging.info("  -> %d lignes lues (hors en-tête)", len(rows))
    return rows


# --------------------------------------------------------
# Helpers
# --------------------------------------------------------
def to_float(value, default=None):
    try:
        return float(value)
    except Exception:
        return default


def to_bool_success(value):
    if value is None:
        return False
    v = str(value).strip().lower()
    return v in ("true", "1", "yes", "y")


def percentile(values, p):
    """
    Percentile simple (0-100) sur une liste de nombres
    """
    if not values:
        return None
    values = sorted(values)
    k = (len(values) - 1) * (p / 100.0)
    f = int(k)
    c = min(f + 1, len(values) - 1)
    if f == c:
        return values[int(k)]
    d0 = values[f] * (c - k)
    d1 = values[c] * (k - f)
    return d0 + d1


def compute_execution_range_string(rows):
    """
    Calcule la date/heure de début et fin du scénario à partir des timeStamp JMeter.
    Format : 21/11/25 09:42 PM - 21/11/25 10:00 PM
    """
    timestamps = []
    for r in rows:
        ts = r.get("timeStamp")
        if ts is None:
            continue
        try:
            timestamps.append(int(ts))
        except ValueError:
            continue

    if not timestamps:
        return ""

    start_ts = min(timestamps) / 1000.0
    end_ts = max(timestamps) / 1000.0

    start_dt = datetime.fromtimestamp(start_ts)
    end_dt = datetime.fromtimestamp(end_ts)

    fmt = "%d/%m/%y %I:%M %p"  # 21/11/25 09:42 PM
    return f"{start_dt.strftime(fmt)} - {end_dt.strftime(fmt)}"


# XML escape simple
def xml_escape(text: str) -> str:
    if text is None:
        return ""
    return (
        str(text)
        .replace("&", "&amp;")
        .replace("<", "&lt;")
        .replace(">", "&gt;")
        .replace('"', "&quot;")
    )


# --------------------------------------------------------
# Calcul du recap par scénario
# --------------------------------------------------------
def compute_recap(rows):
    logging.info("Calcul du tableau récapitulatif pour le scénario...")
    labels = {}

    for r in rows:
        label = r.get("label")
        elapsed_raw = r.get("elapsed")
        success_raw = r.get("success")

        if label is None or elapsed_raw is None:
            continue

        elapsed = to_float(elapsed_raw)
        if elapsed is None:
            continue

        success = to_bool_success(success_raw)

        if label not in labels:
            labels[label] = {"times": [], "errors": 0}

        labels[label]["times"].append(elapsed)
        if not success:
            labels[label]["errors"] += 1

    recap = []

    total_samples_all = 0
    all_times = []
    total_errors_all = 0

    for label, data in sorted(labels.items(), key=lambda x: x[0]):
        times = data["times"]
        errors = data["errors"]
        samples = len(times)
        if samples == 0:
            continue

        avg = statistics.mean(times)
        mn = min(times)
        mx = max(times)
        std_dev = statistics.pstdev(times) if samples > 1 else 0.0
        p90 = percentile(times, 90)
        p95 = percentile(times, 95)
        p99 = percentile(times, 99)
        err_pct = (errors / samples * 100.0) if samples else 0.0

        recap.append({
            "Label": label,
            "Samples": samples,
            "Average (ms)": round(avg, 2),
            "Min (ms)": mn,
            "Max (ms)": mx,
            "Std Dev (ms)": round(std_dev, 2),
            "90% Line (ms)": round(p90, 2) if p90 is not None else "",
            "95% Line (ms)": round(p95, 2) if p95 is not None else "",
            "99% Line (ms)": round(p99, 2) if p99 is not None else "",
            "Error %": round(err_pct, 2),
        })

        total_samples_all += samples
        total_errors_all += errors
        all_times.extend(times)

    # Ligne TOTAL
    if all_times:
        total_avg = statistics.mean(all_times)
        total_min = min(all_times)
        total_max = max(all_times)
        total_std = statistics.pstdev(all_times) if len(all_times) > 1 else 0.0
        total_err_pct = (total_errors_all / total_samples_all * 100.0) if total_samples_all else 0.0
        p90 = percentile(all_times, 90)
        p95 = percentile(all_times, 95)
        p99 = percentile(all_times, 99)

        recap.append({
            "Label": "TOTAL",
            "Samples": total_samples_all,
            "Average (ms)": round(total_avg, 2),
            "Min (ms)": total_min,
            "Max (ms)": total_max,
            "Std Dev (ms)": round(total_std, 2),
            "90% Line (ms)": round(p90, 2) if p90 is not None else "",
            "95% Line (ms)": round(p95, 2) if p95 is not None else "",
            "99% Line (ms)": round(p99, 2) if p99 is not None else "",
            "Error %": round(total_err_pct, 2),
        })

    logging.info("  -> %d lignes dans le tableau récap (y compris TOTAL)", len(recap))
    return recap


# --------------------------------------------------------
# Excel
# --------------------------------------------------------
def sanitize_sheet_name(name: str) -> str:
    name = re.sub(r'[:\\/?*\[\]]', "_", name)
    if len(name) > 31:
        name = name[:31]
    if not name:
        name = "Sheet"
    return name


def write_excel(output_file: str,
                scenarios_data: dict,
                scenarios_users: list,
                rt_matrix: dict,
                err_matrix: dict):
    logging.info("Création du fichier Excel : %s", output_file)
    workbook = xlsxwriter.Workbook(output_file)

    header_fmt = workbook.add_format({
        "bold": True,
        "bg_color": "#D9D9D9",
        "border": 1
    })
    cell_fmt = workbook.add_format({"border": 1})
    num_fmt = workbook.add_format({"border": 1, "num_format": "0.00"})
    int_fmt = workbook.add_format({"border": 1, "num_format": "0"})  # entier

    # --- Feuilles par scénario (détail) ---
    for sheet_name_raw, rows in scenarios_data.items():
        sheet_name = sanitize_sheet_name(sheet_name_raw)
        logging.info("  -> Création de la feuille : %s", sheet_name)

        ws = workbook.add_worksheet(sheet_name)

        if not rows:
            logging.warning("    (Aucune donnée pour ce scénario)")
            continue

        headers = [
            "Label",
            "Samples",
            "Average (ms)",
            "Min (ms)",
            "Max (ms)",
            "Std Dev (ms)",
            "90% Line (ms)",
            "95% Line (ms)",
            "99% Line (ms)",
            "Error %",
        ]

        for col, h in enumerate(headers):
            ws.write(0, col, h, header_fmt)

        for row_idx, row in enumerate(rows, start=1):
            for col_idx, h in enumerate(headers):
                val = row.get(h, "")
                if isinstance(val, (int, float)):
                    ws.write(row_idx, col_idx, val, num_fmt)
                else:
                    ws.write(row_idx, col_idx, str(val), cell_fmt)

        ws.set_column(0, 0, 40)
        ws.set_column(1, len(headers) - 1, 16)

    # --- Onglet Data Time Response Time (Scenario / API / Response Time) ---
    ws_rt = workbook.add_worksheet("Data Time Response Time")
    ws_rt.write(0, 0, "Scenario", header_fmt)
    ws_rt.write(0, 1, "API", header_fmt)
    ws_rt.write(0, 2, "Response Time (ms)", header_fmt)

    row_idx = 1
    for users in sorted(scenarios_users):
        start_row = row_idx
        for label in LABEL_ORDER:
            val = rt_matrix.get(label, {}).get(users, None)
            if val is None:
                continue
            # API
            ws_rt.write(row_idx, 1, label, cell_fmt)
            # Response time entier
            ws_rt.write(row_idx, 2, int(round(val)), int_fmt)
            row_idx += 1
        end_row = row_idx - 1
        if end_row >= start_row:
            # fusion de la colonne Scenario pour ce bloc
            ws_rt.merge_range(start_row, 0, end_row, 0, users, int_fmt)

    ws_rt.set_column(0, 0, 12)   # Scenario
    ws_rt.set_column(1, 1, 20)   # API
    ws_rt.set_column(2, 2, 20)   # Response Time

    # --- Onglet Data Error Rate (Scenario / API / Error Rate) ---
    ws_err = workbook.add_worksheet("Data Error Rate")
    ws_err.write(0, 0, "Scenario", header_fmt)
    ws_err.write(0, 1, "API", header_fmt)
    ws_err.write(0, 2, "Error Rate (%)", header_fmt)

    row_idx = 1
    for users in sorted(scenarios_users):
        start_row = row_idx
        for label in LABEL_ORDER:
            val = err_matrix.get(label, {}).get(users, None)
            if val is None:
                continue
            ws_err.write(row_idx, 1, label, cell_fmt)

            # formattage ErrorRate :
            # - entier si possible
            # - sinon 2 décimales avec un point (écrit comme texte)
            if abs(val - round(val)) < 1e-9:
                s = str(int(round(val)))
            else:
                s = f"{val:.2f}"  # Python utilise déjà le point comme séparateur
            ws_err.write(row_idx, 2, s, cell_fmt)

            row_idx += 1
        end_row = row_idx - 1
        if end_row >= start_row:
            ws_err.merge_range(start_row, 0, end_row, 0, users, int_fmt)

    ws_err.set_column(0, 0, 12)
    ws_err.set_column(1, 1, 20)
    ws_err.set_column(2, 2, 20)

    workbook.close()
    logging.info("Fichier Excel finalisé.")


# --------------------------------------------------------
# Word helpers (sans python-docx / lxml)
# --------------------------------------------------------
def build_response_time_table_xml(recap):
    """
    Construit le XML Word d'un tableau 'Response time' avec bordures
    et police réduite (~8pt).
    """
    headers = [
        "Label",
        "Samples",
        "Average (ms)",
        "Min (ms)",
        "Max (ms)",
        "Std Dev (ms)",
        "90% Line (ms)",
        "95% Line (ms)",
        "99% Line (ms)",
        "Error %",
    ]

    # Entête (gras, petite taille)
    header_row_xml = "<w:tr>"
    for h in headers:
        header_row_xml += f"""
        <w:tc>
          <w:tcPr/>
          <w:p>
            <w:r>
              <w:rPr>
                <w:b/>
                <w:sz w:val="16"/>   <!-- 8pt -->
                <w:szCs w:val="16"/>
              </w:rPr>
              <w:t>{xml_escape(h)}</w:t>
            </w:r>
          </w:p>
        </w:tc>
        """
    header_row_xml += "</w:tr>"

    # Lignes de données
    data_rows_xml = ""
    for r in recap:
        data_rows_xml += "<w:tr>"

        cells = [
            r["Label"],
            r["Samples"],
            r["Average (ms)"],
            r["Min (ms)"],
            r["Max (ms)"],
            r["Std Dev (ms)"],
            r["90% Line (ms)"],
            r["95% Line (ms)"],
            r["99% Line (ms)"],
            r["Error %"],
        ]

        for val in cells:
            text = xml_escape(val)
            data_rows_xml += f"""
            <w:tc>
              <w:tcPr/>
              <w:p>
                <w:r>
                  <w:rPr>
                    <w:sz w:val="16"/>
                    <w:szCs w:val="16"/>
                  </w:rPr>
                  <w:t>{text}</w:t>
                </w:r>
              </w:p>
            </w:tc>
            """

        data_rows_xml += "</w:tr>"

    table_xml = f"""
    <w:tbl>
      <w:tblPr>
        <w:tblBorders>
          <w:top w:val="single" w:sz="8" w:space="0" w:color="000000"/>
          <w:left w:val="single" w:sz="8" w:space="0" w:color="000000"/>
          <w:bottom w:val="single" w:sz="8" w:space="0" w:color="000000"/>
          <w:right w:val="single" w:sz="8" w:space="0" w:color="000000"/>
          <w:insideH w:val="single" w:sz="4" w:space="0" w:color="000000"/>
          <w:insideV w:val="single" w:sz="4" w:space="0" w:color="000000"/>
        </w:tblBorders>
      </w:tblPr>
      {header_row_xml}
      {data_rows_xml}
    </w:tbl>
    """
    return table_xml


def replace_paragraph_with_table(xml: str, placeholder: str, table_xml: str):
    """
    Remplace le paragraphe <w:p> qui contient `placeholder`
    par le tableau XML complet `table_xml`.
    Retourne (xml_modifié, remplacé_bool).
    """
    idx = xml.find(placeholder)
    if idx == -1:
        return xml, False

    # début du paragraphe
    p_start = xml.rfind("<w:p", 0, idx)
    if p_start == -1:
        return xml, False

    # fin du paragraphe
    p_end = xml.find("</w:p>", idx)
    if p_end == -1:
        return xml, False
    p_end += len("</w:p>")

    new_xml = xml[:p_start] + table_xml + xml[p_end:]
    return new_xml, True


def generate_word_report(template_path, output_path,
                         scenarios_users, scenario_recaps, scenario_rows):
    """
    Modifie le template Word (DOCX comme ZIP) :
      - remplit les dates d'exécution : {EXEC_DATE_1}, {EXEC_DATE_2}, ...
      - insère les tableaux Response time : {RT_TABLE_1}, {RT_TABLE_2}, ...
    """
    if not template_path:
        logging.warning("DOC_TEMPLATE non défini, génération Word ignorée.")
        return

    if not os.path.isfile(template_path):
        logging.error("DOC_TEMPLATE n'existe pas : %s", template_path)
        return

    logging.info("Ouverture du template Word (ZIP) : %s", template_path)

    # Lire tout le DOCX dans un dict {nom_fichier: bytes}
    with ZipFile(template_path, "r") as z:
        content = {name: z.read(name) for name in z.namelist()}

    if "word/document.xml" not in content:
        logging.error("Le fichier word/document.xml est introuvable dans le template.")
        return

    xml = content["word/document.xml"].decode("utf-8")

    # 1) Dates d'exécution
    exec_strings = []
    for users in sorted(scenarios_users):
        rows = scenario_rows.get(users, [])
        exec_strings.append(compute_execution_range_string(rows))

    for i, date_str in enumerate(exec_strings, start=1):
        placeholder = f"{{EXEC_DATE_{i}}}"
        if placeholder in xml:
            xml = xml.replace(placeholder, xml_escape(date_str))
            logging.info("Remplacement de %s par '%s'", placeholder, date_str)
        else:
            logging.info("Placeholder %s non trouvé dans le document.", placeholder)

    # 2) Tableaux Response time
    tables_to_append = []  # ceux dont le placeholder n'est pas trouvé

    for idx, users in enumerate(sorted(scenarios_users), start=1):
        recap = scenario_recaps.get(users)
        if not recap:
            continue

        placeholder = f"{{RT_TABLE_{idx}}}"
        table_xml = build_response_time_table_xml(recap)

        xml, replaced = replace_paragraph_with_table(xml, placeholder, table_xml)
        if replaced:
            logging.info("Tableau Response time inséré à la place de %s (users=%d)", placeholder, users)
        else:
            logging.info(
                "Placeholder %s non trouvé en paragraphe pour users=%d, on ajoutera le tableau en fin de doc.",
                placeholder, users
            )
            tables_to_append.append(table_xml)

    # fallback : ajouter les tableaux restants en fin de document
    if tables_to_append:
        concat_tables = "\n".join(tables_to_append)
        insert_tag = "</w:body>"
        if insert_tag not in xml:
            insert_tag = "</w:document>"
        xml = xml.replace(insert_tag, concat_tables + insert_tag)
        logging.info("%d tableau(x) ajouté(s) en fin de document (fallback).", len(tables_to_append))

    # Écrire le nouveau DOCX
    with ZipFile(output_path, "w") as z:
        for name, data in content.items():
            if name == "word/document.xml":
                z.writestr(name, xml.encode("utf-8"))
            else:
                z.writestr(name, data)

    logging.info("Document Word généré : %s", output_path)


# --------------------------------------------------------
# MAIN
# --------------------------------------------------------
def main():
    try:
        results_folder, output_file, doc_template, doc_output = load_env()
        files = find_scenario_files(results_folder)

        scenarios_data = {}
        scenarios_users = []
        rt_matrix = defaultdict(dict)   # label -> {users: avg}
        err_matrix = defaultdict(dict)  # label -> {users: error%}
        scenario_rows = {}              # users -> rows CSV
        scenario_recaps_by_users = {}   # users -> recap

        for f in files:
            logging.info("--------------------------------------------------")
            logging.info("Traitement du fichier scénario : %s", f)

            users = extract_users_from_filename(f)
            if users not in scenarios_users:
                scenarios_users.append(users)

            rows = read_jmeter_csv(f)
            recap = compute_recap(rows)

            base_name = os.path.splitext(os.path.basename(f))[0]
            scenarios_data[base_name] = recap
            scenario_rows[users] = rows
            scenario_recaps_by_users[users] = recap

            # alimenter les matrices pour les onglets Data*
            for r in recap:
                if r["Label"] == "TOTAL":
                    continue
                label = r["Label"]
                rt_matrix[label][users] = r["Average (ms)"]
                err_matrix[label][users] = r["Error %"]

        write_excel(output_file, scenarios_data, scenarios_users, rt_matrix, err_matrix)

        # Génération du Word si les chemins sont définis
        if doc_template and doc_output:
            generate_word_report(doc_template, doc_output,
                                 scenarios_users, scenario_recaps_by_users, scenario_rows)
        else:
            logging.info("DOC_TEMPLATE ou DOC_OUTPUT non défini, Word ignoré.")

        logging.info("Terminé ✅")

    except Exception as e:
        logging.exception("❌ Erreur lors de l'exécution du script : %s", e)


if __name__ == "__main__":
    main()
